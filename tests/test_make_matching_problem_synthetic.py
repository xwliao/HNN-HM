import numpy as np

from utils import create_tensor
from utils.create_tensor import _sort_each_edge
from utils.create_tensor import _unique_all_edges

import utils.make_matching_problem_synthetic as mmp
from utils.make_matching_problem_synthetic import make_matching_problem


def assert_same_problems(problem1, problem2):
  def assert_allclose(v1, v2, *args, **kwargs):
    if (v1 is None) or (v2 is None):
      assert v1 is None
      assert v2 is None
    else:
      np.testing.assert_allclose(v1, v2, *args, **kwargs)
  assert problem1["nP1"] == problem2["nP1"]
  assert problem1["nP2"] == problem2["nP2"]
  assert_allclose(problem1["P1"], problem2["P1"], rtol=1e-4, atol=0)
  assert_allclose(problem1["P2"], problem2["P2"], rtol=1e-4, atol=0)
  assert_allclose(problem1["indH1"], problem2["indH1"], rtol=1e-4, atol=0)
  assert_allclose(problem1["valH1"], problem2["valH1"], rtol=1e-4, atol=0)
  assert_allclose(problem1["indH2"], problem2["indH2"], rtol=1e-4, atol=0)
  assert_allclose(problem1["valH2"], problem2["valH2"], rtol=1e-4, atol=0)
  assert_allclose(problem1["indH3"], problem2["indH3"], rtol=1e-4, atol=0)
  assert_allclose(problem1["valH3"], problem2["valH3"], rtol=1e-4, atol=0)
  assert_allclose(problem1["assignmentMatrix"], problem2["assignmentMatrix"], rtol=1e-4, atol=0)


def read_saved_matching_problem():
  P1 = np.loadtxt('test_data/P1.txt').T  # nP1 x 2
  P2 = np.loadtxt('test_data/P2.txt').T  # nP2 x 2
  nP1 = P1.shape[0]
  nP2 = P2.shape[0]

  # 1st order tensor
  indH1 = None  # TODO: Or np.zeros((0, 1), dtype=np.int32)?
  valH1 = None  # TODO: Or np.zeros((0, 1), dtype=np.float64)?

  # 2nd order tensor
  indH2 = None  # TODO: Or np.zeros((0, 2), dtype=np.int32)?
  valH2 = None  # TODO: Or np.zeros((0, 1), dtype=np.float64)?

  indH3 = np.loadtxt('test_data/indH3.txt')
  valH3 = np.loadtxt('test_data/valH3.txt')

  # TODO: test sort_each_edge and unique_all_edges
  indH3, valH3 = _sort_each_edge(indH3, valH3)
  indH3, valH3 = _unique_all_edges(indH3, valH3)

  indH3 = indH3.astype(np.int32)
  valH3 = valH3.astype(np.float64)

  assignmentMatrix = np.loadtxt('test_data/assignmentMatrix.txt', dtype=np.bool)

  problem = {
      "nP1": nP1,
      "nP2": nP2,
      "P1": P1,
      "P2": P2,
      "indH1": indH1,
      "valH1": valH1,
      "indH2": indH2,
      "valH2": valH2,
      "indH3": indH3,
      "valH3": valH3,
      "assignmentMatrix": assignmentMatrix
  }
  return problem


def _test_make_matching_problem_helper(settings):
  """Run without any correctness checking to ensure the code is runnable"""
  problem = make_matching_problem(settings)
  assert problem is not None

  assert "nP1" in problem
  assert "nP2" in problem
  assert "P1" in problem
  assert "P2" in problem
  assert "indH1" in problem
  assert "valH1" in problem
  assert "indH2" in problem
  assert "valH2" in problem
  assert "indH3" in problem
  assert "valH3" in problem
  assert "assignmentMatrix" in problem

  assert problem["nP1"] is not None
  assert problem["nP2"] is not None
  assert problem["P1"] is not None
  assert problem["P2"] is not None
  assert problem["assignmentMatrix"] is not None


def test_make_matching_problem():
  settings = {
      "nInlier": 20,
      "nOutlier": 0,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": True,
  }
  _test_make_matching_problem_helper(settings)

  settings = {
      "nInlier": 20,
      "nOutlier": 0,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": True,
  }
  _test_make_matching_problem_helper(settings)

  settings = {
      "nInlier": 20,
      "nOutlier": 0,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": False,
  }
  _test_make_matching_problem_helper(settings)

  settings = {
      "nInlier": 20,
      "nOutlier": 0,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": False,
  }
  _test_make_matching_problem_helper(settings)


def test_make_matching_problem_comparison(monkeypatch):
  """Run make_matching_problem and compare its result with the saved result generated by the Matlab code"""
  settings = {
      "nInlier": 20,
      "nOutlier": 0,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": True,
  }

  saved_problem = read_saved_matching_problem()

  def mock_generate_point_sets(settings, rng=None):
    P1 = saved_problem["P1"]  # nP1 x 2
    P2 = saved_problem["P2"]  # nP2 x 2
    assignmentMatrix = saved_problem["assignmentMatrix"]
    return P1, P2, assignmentMatrix
  monkeypatch.setattr(mmp, "_generate_point_sets", mock_generate_point_sets)

  def mock_generate_triangles(nP1, nT, rng=None):
    T1 = np.loadtxt('test_data/T1.txt', dtype=np.int32).T  # nT x 3
    return T1
  monkeypatch.setattr(create_tensor, "_generate_triangles", mock_generate_triangles)

  # def mock_compute_feature(P1, P2, T1):
  #   feat1 = np.loadtxt('test_data/feat1.txt').T  # nT x 3
  #   feat2 = np.loadtxt('test_data/feat2.txt').T  # (nP2**3) x 3
  #   return feat1, feat2
  # # TODO: Remove this patch!
  # # This patch is unnecessary, but without it, the comparison of `indH3` will failed.
  # monkeypatch.setattr(mmp, "compute_feature", mock_compute_feature)

  problem = make_matching_problem(settings)

  assert problem is not None

  for k, v in saved_problem.items():
    assert k in problem
    # if v is not None:
    #   np.testing.assert_allclose(problem[k], v, rtol=1e-4, atol=0)

  assert problem["nP1"] == saved_problem["nP1"]
  assert problem["nP2"] == saved_problem["nP2"]
  np.testing.assert_allclose(problem["P1"], saved_problem["P1"], rtol=1e-4, atol=0)
  np.testing.assert_allclose(problem["P2"], saved_problem["P2"], rtol=1e-4, atol=0)
  # np.testing.assert_allclose(problem["indH1"], saved_problem["indH1"], rtol=1e-4, atol=0)
  # np.testing.assert_allclose(problem["valH1"], saved_problem["valH1"], rtol=1e-4, atol=0)
  # np.testing.assert_allclose(problem["indH2"], saved_problem["indH2"], rtol=1e-4, atol=0)
  # np.testing.assert_allclose(problem["valH2"], saved_problem["valH2"], rtol=1e-4, atol=0)
  np.testing.assert_allclose(problem["indH3"], saved_problem["indH3"], rtol=1e-4, atol=0)
  np.testing.assert_allclose(problem["valH3"], saved_problem["valH3"], rtol=1e-4, atol=0)
  np.testing.assert_allclose(problem["assignmentMatrix"], saved_problem["assignmentMatrix"], rtol=1e-4, atol=0)


def _test_make_matching_problem_rng_helper(settings, n_problem, seed):
  rng1 = np.random.default_rng(seed)
  rng2 = np.random.default_rng(seed)

  for _ in range(n_problem):
    problem1 = make_matching_problem(settings, rng=rng1)
    problem2 = make_matching_problem(settings, rng=rng2)
    assert_same_problems(problem1, problem2)


def test_make_matching_problem_rng():
  # Without outliers
  settings = {
      "nInlier": 20,
      "nOutlier": 0,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": True,
  }
  _test_make_matching_problem_rng_helper(settings, n_problem=10, seed=101)
  _test_make_matching_problem_rng_helper(settings, n_problem=10, seed=1024)

  # With outliers
  settings = {
      "nInlier": 20,
      "nOutlier": 5,
      "deformation": 0.025,
      "typeDistribution": 'normal',  # normal / uniform
      "transScale": 1.0,   # scale change
      "transRotate": 0.0,  # rotation change
      "scale": 0.2,
      "bPermute": True,
  }
  _test_make_matching_problem_rng_helper(settings, n_problem=10, seed=101)
  _test_make_matching_problem_rng_helper(settings, n_problem=10, seed=1024)


if __name__ == '__main__':
  test_make_matching_problem()
  test_make_matching_problem_rng()
